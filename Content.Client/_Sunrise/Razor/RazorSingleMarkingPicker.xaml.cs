// © SUNRISE, An EULA/CLA with a hosting restriction, full text: https://github.com/space-sunrise/space-station-14/blob/master/CLA.txt;

using System.Linq;
using Content.Shared.Humanoid.Markings;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;

namespace Content.Client._Sunrise.Razor;

[GenerateTypedNameReferences]
public sealed partial class RazorSingleMarkingPicker : BoxContainer
{
    [Dependency] private readonly MarkingManager _markingManager = default!;

    public Action<(int slot, string id)>? OnMarkingSelect;
    public Action<int>? OnSlotRemove;
    public Action? OnSlotAdd;

    private int _slot = -1;
    private int Slot
    {
        get
        {
            if (_markings == null || _markings.Count == 0)
            {
                _slot = -1;
            }
            else if (_slot == -1)
            {
                _slot = 0;
            }

            return _slot;
        }
        set
        {
            if (_markings == null || _markings.Count == 0)
            {
                _slot = -1;
                return;
            }

            _slot = value;
            _ignoreItemSelected = true;

            foreach (var item in MarkingList)
            {
                item.Selected = (string) item.Metadata! == _markings[_slot].MarkingId;
            }

            _ignoreItemSelected = false;
        }
    }

    private int _totalPoints;

    private bool _ignoreItemSelected;

    private MarkingCategories _category;
    public MarkingCategories Category
    {
        get => _category;
        set
        {
            _category = value;
            CategoryName.Text = Loc.GetString($"markings-category-{_category}");

            if (!string.IsNullOrEmpty(_species))
            {
                PopulateList(Search.Text);
            }
        }
    }
    private IReadOnlyDictionary<string, MarkingPrototype>? _markingPrototypeCache;

    private string? _species;
    private List<Marking>? _markings;

    private int PointsLeft
    {
        get
        {
            if (_markings == null)
            {
                return 0;
            }

            if (_totalPoints < 0)
            {
                return -1;
            }

            return _totalPoints - _markings.Count;
        }
    }

    private int PointsUsed => _markings?.Count ?? 0;

    public RazorSingleMarkingPicker()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        MarkingList.OnItemSelected += SelectMarking;
        AddButton.OnPressed += _ =>
        {
            OnSlotAdd!();
        };

        SlotSelector.OnItemSelected += args =>
        {
            Slot = args.Button.SelectedId;
        };

        RemoveButton.OnPressed += _ =>
        {
            OnSlotRemove!(_slot);
        };

        Search.OnTextChanged += args =>
        {
            PopulateList(args.Text);
        };
    }

    public void UpdateData(List<Marking> markings, string species, int totalPoints)
    {
        _markings = markings;
        _species = species;
        _totalPoints = totalPoints;

        _markingPrototypeCache = _markingManager.MarkingsByCategoryAndSpecies(Category, _species);

        Visible = _markingPrototypeCache.Count != 0;
        if (_markingPrototypeCache.Count == 0)
        {
            return;
        }

        PopulateList(Search.Text);
        PopulateSlotSelector();
    }

    public void PopulateList(string filter)
    {
        if (string.IsNullOrEmpty(_species))
        {
            throw new ArgumentException("Tried to populate marking list without a set species!");
        }

        _markingPrototypeCache ??= _markingManager.MarkingsByCategoryAndSpecies(Category, _species);

        MarkingSelectorContainer.Visible = _markings != null && _markings.Count != 0;
        if (_markings == null || _markings.Count == 0)
        {
            return;
        }

        MarkingList.Clear();

        var sortedMarkings = _markingPrototypeCache.Where(m =>
            m.Key.ToLower().Contains(filter.ToLower()) ||
            GetMarkingName(m.Value).ToLower().Contains(filter.ToLower())
        )
        .OrderBy(p => Loc.GetString($"marking-{p.Key}"));

        foreach (var (id, marking) in sortedMarkings)
        {
            var item = MarkingList.AddItem(Loc.GetString($"marking-{id}"), marking.Sprites[0].Frame0());
            item.Metadata = marking.ID;
            if (marking.SponsorOnly)
            {
                item.Disabled = false;
                item.Text = Loc.GetString("sponsor-marking", ("name", GetMarkingName(marking)));
            }

            if (_markings[Slot].MarkingId == id)
            {
                _ignoreItemSelected = true;
                item.Selected = true;
                _ignoreItemSelected = false;
            }
        }
    }

    private void SelectMarking(ItemList.ItemListSelectedEventArgs args)
    {
        if (_ignoreItemSelected)
        {
            return;
        }

        var id = (string) MarkingList[args.ItemIndex].Metadata!;
        if (!_markingManager.Markings.TryGetValue(id, out var proto))
        {
            throw new ArgumentException("Attempted to select non-existent marking.");
        }

        var oldMarking = _markings![Slot];
        _markings[Slot] = proto.AsMarking();

        for (var i = 0; i < _markings[Slot].MarkingColors.Count && i < oldMarking.MarkingColors.Count; i++)
        {
            _markings[Slot].SetColor(i, oldMarking.MarkingColors[i]);
        }

        OnMarkingSelect!((_slot, id));
    }

    private void PopulateSlotSelector()
    {
        SlotSelector.Visible = Slot >= 0;
        Search.Visible = Slot >= 0;
        AddButton.HorizontalExpand = Slot < 0;
        RemoveButton.HorizontalExpand = Slot < 0;
        AddButton.Disabled = PointsLeft == 0 && _totalPoints > -1 ;
        RemoveButton.Disabled = PointsUsed == 0;
        SlotSelector.Clear();

        if (Slot < 0)
        {
            return;
        }

        for (var i = 0; i < PointsUsed; i++)
        {
            SlotSelector.AddItem(Loc.GetString("slot-marking", ("name", i + 1)), i);

            if (i == _slot)
            {
                SlotSelector.SelectId(i);
            }
        }
    }

    private string GetMarkingName(MarkingPrototype marking)
    {
        return Loc.GetString($"marking-{marking.ID}");
    }
}
