using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Content.Shared.DropPod;

namespace Content.Client.DropPod.UI;

[GenerateTypedNameReferences]
public sealed partial class DropPodConsoleWindow : DefaultWindow
{
    public event Action<int>? PointSelected;
    public event Action? PointsRefreshButtonPressed;
    public event Action? StartLandingButtonPressed;

    public DropPodConsoleWindow()
    {
        RobustXamlLoader.Load(this);

        DropPodRefreshPointsButton.OnPressed += _ => PointsRefreshButtonPressed?.Invoke();
        DropPodStartLandingButton.OnPressed += _ => StartLandingButtonPressed?.Invoke();
        SubnetList.OnItemSelected += OnSubnetListSelect;
    }

    public void UpdateState(DropPodUiState state)
    {
        DropPodRefreshPointsButton.Disabled = !state.CanRefreshVol;
        DropPodStartLandingButton.Disabled = !state.CanStartVol;
        AddPointToList(state);
    }

    private void AddPointToList(DropPodUiState state)
    {
        SubnetList.Clear(); // We clean it so that there are no duplicated buttons
        foreach (var point in state.Points)
        {
            var item = SubnetList.AddItem($"{point.Value}");
            item.Metadata = point.Key; // The key contains a unique identification number (UIN), which, according to my logic, each landing point has its own
        }
    }

    private void OnSubnetListSelect(ItemList.ItemListSelectedEventArgs args)
    {
        PointSelected!((int) SubnetList[args.ItemIndex].Metadata!); // When selecting the desired object in the SubnetList, we send a unique identification number by which we will search for the desired landing point
    }
}
